// Copyright (C) 2002-2012 Nikolaus Gebhardt
// This file is part of the "Irrlicht Engine".
// For conditions of distribution and use, see copyright notice in irrlicht.h

#ifndef __I_MESH_BUFFER_H_INCLUDED__
#define __I_MESH_BUFFER_H_INCLUDED__

#include <algorithm>

#include "ITransformFeedback.h"
#include "SMaterial.h"
#include "aabbox3d.h"
#include "irr/asset/ICPUBuffer.h"
#include "IGPUBuffer.h"
#include "vectorSIMD.h"
#include "coreutil.h"
#include "CBAWFile.h"
#include "assert.h"

namespace irr
{
namespace scene
{

	//! Enumeration for all primitive types there are.
	enum E_PRIMITIVE_TYPE
	{
		//! All vertices are non-connected points.
		EPT_POINTS=0,

		//! All vertices form a single connected line.
		EPT_LINE_STRIP,

		//! Just as LINE_STRIP, but the last and the first vertex is also connected.
		EPT_LINE_LOOP,

		//! Every two vertices are connected creating n/2 lines.
		EPT_LINES,

		//! After the first two vertices each vertex defines a new triangle.
		//! Always the two last and the new one form a new triangle.
		EPT_TRIANGLE_STRIP,

		//! After the first two vertices each vertex defines a new triangle.
		//! All around the common first vertex.
		EPT_TRIANGLE_FAN,

		//! Explicitly set all vertices for each triangle.
		EPT_TRIANGLES

		// missing adjacency types and patches
	};

	//!
    enum E_INDEX_TYPE
    {
        EIT_16BIT = 0,
        EIT_32BIT,
        EIT_UNKNOWN
    };

	//! Available vertex attribute ids
	/** As of 2018 most OpenGL implementations support 16 attributes (some CAD GPUs more) */
    enum E_VERTEX_ATTRIBUTE_ID
    {
        EVAI_ATTR0=0,
        EVAI_ATTR1,
        EVAI_ATTR2,
        EVAI_ATTR3,
        EVAI_ATTR4,
        EVAI_ATTR5,
        EVAI_ATTR6,
        EVAI_ATTR7,
        EVAI_ATTR8,
        EVAI_ATTR9,
        EVAI_ATTR10,
        EVAI_ATTR11,
        EVAI_ATTR12,
        EVAI_ATTR13,
        EVAI_ATTR14,
        EVAI_ATTR15,
        EVAI_COUNT
    };

	//! Available components' sizes enumeration
    enum E_COMPONENTS_PER_ATTRIBUTE
    {
		//! Special ID for reverse XYZW order
        ECPA_REVERSED_OR_BGRA=0,
        ECPA_ONE,
        ECPA_TWO,
        ECPA_THREE,
        ECPA_FOUR,
        ECPA_COUNT
    };

	//! Available components' type
    enum E_COMPONENT_TYPE
    {
        ECT_FLOAT=0,
        ECT_HALF_FLOAT,
        ECT_DOUBLE_IN_FLOAT_OUT,
        ECT_UNSIGNED_INT_10F_11F_11F_REV,
        //INTEGER FORMS
        ECT_NORMALIZED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV,
        ECT_NORMALIZED_BYTE,
        ECT_NORMALIZED_UNSIGNED_BYTE,
        ECT_NORMALIZED_SHORT,
        ECT_NORMALIZED_UNSIGNED_SHORT,
        ECT_NORMALIZED_INT,
        ECT_NORMALIZED_UNSIGNED_INT,
        ECT_INT_2_10_10_10_REV,
        ECT_UNSIGNED_INT_2_10_10_10_REV,
        ECT_BYTE,
        ECT_UNSIGNED_BYTE,
        ECT_SHORT,
        ECT_UNSIGNED_SHORT,
        ECT_INT,
        ECT_UNSIGNED_INT,
        ECT_INTEGER_INT_2_10_10_10_REV,
        ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV,
        ECT_INTEGER_BYTE,
        ECT_INTEGER_UNSIGNED_BYTE,
        ECT_INTEGER_SHORT,
        ECT_INTEGER_UNSIGNED_SHORT,
        ECT_INTEGER_INT,
        ECT_INTEGER_UNSIGNED_INT,
        //special
        ECT_DOUBLE_IN_DOUBLE_OUT, //only accepted by glVertexAttribLPointer
        ECT_COUNT
    };

    enum E_MESH_BUFFER_TYPE
    {
        EMBT_UNKNOWN = 0,
        EMBT_NOT_ANIMATED,
        EMBT_ANIMATED_FRAME_BASED,
        EMBT_ANIMATED_SKINNED
    };
/**
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.

GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.

GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.

GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
**/
    static size_t vertexAttrSize[ECT_COUNT][ECPA_COUNT] = {
        {0xdeadbeefu,4,8,12,16}, // ECT_FLOAT
        {0xdeadbeefu,2,4,6,8}, // ECT_HALF_FLOAT
        {0xdeadbeefu,8,16,24,32}, // ECT_DOUBLE_IN_FLOAT_OUT
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4,0xdeadbeefu}, //ECT_UNSIGNED_INT_10F_11F_11F_REV
        //integers
        //normalized
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_INT_2_10_10_10_REV
        {4,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, //ECT_NORMALIZED_BYTE
        {4,1,2,3,4}, // ECT_NORMALIZED_UNSIGNED_BYTE
        {0xdeadbeefu,2,4,6,8}, // ECT_NORMALIZED_SHORT
        {0xdeadbeefu,2,4,6,8}, // ECT_NORMALIZED_UNSIGNED_SHORT
        {0xdeadbeefu,4,8,12,16}, // ECT_NORMALIZED_INT
        {0xdeadbeefu,4,8,12,16}, // ECT_NORMALIZED_UNSIGNED_INT
        //un normalized ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, // ECT_INT_2_10_10_10_REV
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, // ECT_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, // ECT_BYTE
        {0xdeadbeefu,1,2,3,4}, // ECT_UNSIGNED_BYTE
        {0xdeadbeefu,2,4,6,8}, // ECT_SHORT
        {0xdeadbeefu,2,4,6,8}, // ECT_UNSIGNED_SHORT
        {0xdeadbeefu,4,8,12,16}, // ECT_INT
        {0xdeadbeefu,4,8,12,16}, // ECT_UNSIGNED_INT
        //native ints
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, // ECT_INTEGER_INT_2_10_10_10_REV
        {0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,0xdeadbeefu,4}, // ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV
        {0xdeadbeefu,1,2,3,4}, // ECT_INTEGER_BYTE
        {0xdeadbeefu,1,2,3,4}, // ECT_INTEGER_UNSIGNED_BYTE
        {0xdeadbeefu,2,4,6,8}, // ECT_INTEGER_SHORT
        {0xdeadbeefu,2,4,6,8}, // ECT_INTEGER_UNSIGNED_SHORT
        {0xdeadbeefu,4,8,12,16}, // ECT_INTEGER_INT
        {0xdeadbeefu,4,8,12,16}, // ECT_INTEGER_UNSIGNED_INT
        //special
        {0xdeadbeefu,8,16,24,32} // ECT_DOUBLE_IN_DOUBLE_OUT
    };

	//! Checks whether given combination of attribute's type and component count is valid
	/** In OpenGL some formats are special like RGB30_A2 or RGB9_E5 which force the number of components and give no flexibility in the number of channels
	@param type Type of an atrribute.
	@param components Component count of an atrribute.
	@returns true if such combination is valid or false otherwise.
	*/
    inline bool validCombination(const E_COMPONENT_TYPE& type, const E_COMPONENTS_PER_ATTRIBUTE& components)
    {
        return vertexAttrSize[type][components]<0xdeadbeefu;
    }

	//! Checks whether given attribute type is a normalized one.
	/** @param type Type of an attribute.
	@returns true if given attribute type is normalized or false otherwise.
	*/
    inline bool isNormalized(const E_COMPONENT_TYPE& type)
    {
        return type >= ECT_NORMALIZED_INT_2_10_10_10_REV && type <= ECT_NORMALIZED_UNSIGNED_INT;
    }

	//! Checks whether given attribute type is "weak integer", e.g. is an integer accessed as floating-point on shader-side.
	/** @param type Type of an attribute.
	@returns true if given attribute type is "weak integer" or false otherwise.
	*/
	inline bool isWeakInteger(const E_COMPONENT_TYPE& type)
	{
		if (isNormalized(type))
			return true;
		switch (type)
		{
			case ECT_INT_2_10_10_10_REV:
			case ECT_UNSIGNED_INT_2_10_10_10_REV:
			case ECT_BYTE:
			case ECT_UNSIGNED_BYTE:
			case ECT_SHORT:
			case ECT_UNSIGNED_SHORT:
			case ECT_INT:
			case ECT_UNSIGNED_INT:
				return true;
            default:
                break;
		}
		return false;
	}

	//! Checks whether given attribute type is an integer accessed as integer on shader-side.
	/** @param type Type of an attribute.
	@returns true if given attribute type is native integer or false otherwise.
	*/
	inline bool isNativeInteger(const E_COMPONENT_TYPE& type)
	{
		switch (type)
		{
		case ECT_INTEGER_INT_2_10_10_10_REV:
		case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_INTEGER_BYTE:
		case ECT_INTEGER_UNSIGNED_BYTE:
		case ECT_INTEGER_SHORT:
		case ECT_INTEGER_UNSIGNED_SHORT:
		case ECT_INTEGER_INT:
		case ECT_INTEGER_UNSIGNED_INT:
			return true;
        default:
            break;
		}
		return false;
	}

	//! Checks whether given attribute type is unsigned.
	/** @param type Type of an attribute.
	@returns true if given attribute type is unsigned or false otherwise.
	*/
	inline bool isUnsigned(const E_COMPONENT_TYPE& type)
	{
		switch (type)
		{
		case ECT_UNSIGNED_INT_10F_11F_11F_REV:
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_NORMALIZED_UNSIGNED_BYTE:
		case ECT_NORMALIZED_UNSIGNED_SHORT:
		case ECT_NORMALIZED_UNSIGNED_INT:
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_UNSIGNED_BYTE:
		case ECT_UNSIGNED_SHORT:
		case ECT_UNSIGNED_INT:
		case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_INTEGER_UNSIGNED_BYTE:
		case ECT_INTEGER_UNSIGNED_SHORT:
		case ECT_INTEGER_UNSIGNED_INT:
			return true;
        default:
            break;
		}
		return false;
	}

	//! Checks whether given attribute type is signed.
	/** @param type Type of an attribute.
	@returns true if given attribute type is signed or false otherwise.
	*/
	inline bool isSigned(const E_COMPONENT_TYPE& type)
	{
		return !isUnsigned(type);
	}

	//! Returns max representable value on given attribute type on given component. Only for attribute types available to get by ICPUMeshBuffer::getAttribute(core::vectorSIMDf&, const E_VERTEX_ATTRIBUTE_ID&, size_t) (all except *_INTEGER_* ones).
	/**
	@param _attrType Attribute type.
	@param _cmpnt Num of component (must be less than 4).
	@returns Max representable value or 0 if given type is not supported by this function (see maxValueOfTypeINT()) or given type does not support given amount of components.
	@see @ref maxValueOfTypeINT()
	*/
	inline float maxValueOfTypeFP(E_COMPONENT_TYPE _attrType, size_t _cmpnt)
	{
		if (isNormalized(_attrType))
			return 1.f;

		switch (_attrType)
		{
		case ECT_FLOAT:
		case ECT_DOUBLE_IN_FLOAT_OUT:
			return FLT_MAX;
		case ECT_HALF_FLOAT:
			return 65504.f;
		case ECT_UNSIGNED_INT_10F_11F_11F_REV:
			if (_cmpnt == 2)
				return 64512.f;
			else if (_cmpnt < 2)
				return 65024.f;
			break;
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return 3;
			else
				return 0x3ff;
		case ECT_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return 1.f;
			else
				return 0x3ff / 2;
		case ECT_BYTE:
			return SCHAR_MAX;
		case ECT_UNSIGNED_BYTE:
			return UCHAR_MAX;
		case ECT_SHORT:
			return SHRT_MAX;
		case ECT_UNSIGNED_SHORT:
			return USHRT_MAX;
		case ECT_NORMALIZED_INT:
		case ECT_INT:
			return INT_MAX;
		case ECT_UNSIGNED_INT:
			return UINT_MAX;
        default:
            break;
		}
		return 0.f;
	}

	//! Returns min representable value on given attribute type on given component. Only for attribute types available to get by ICPUMeshBuffer::getAttribute(core::vectorSIMDf&, const E_VERTEX_ATTRIBUTE_ID&, size_t) (all except *_INTEGER_* ones).
	/**
	@param _attrType Attribute type.
	@param _cmpnt Num of component (must be less than 4).
	@returns Min representable value or positive value if given type is not supported by this function (see minValueOfTypeINT()) or given type does not support given amount of components.
	@see @ref minValueOfTypeINT()
	*/
	inline float minValueOfTypeFP(E_COMPONENT_TYPE _attrType, size_t _cmpnt)
	{
		switch (_attrType)
		{
		case ECT_FLOAT:
		case ECT_DOUBLE_IN_FLOAT_OUT:
			return -FLT_MAX;
		case ECT_HALF_FLOAT:
			return -65504.f;
		case ECT_UNSIGNED_INT_10F_11F_11F_REV:
			if (_cmpnt < 2)
				return 0.f;
			break;
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
			return 0.f;
		case ECT_NORMALIZED_INT_2_10_10_10_REV:
			return -1.f;
		case ECT_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return -2.f;
			else
				return -0x3ff/2 - 1;
		case ECT_NORMALIZED_BYTE:
			return -1.f;
		case ECT_BYTE:
			return SCHAR_MIN;
		case ECT_NORMALIZED_UNSIGNED_BYTE:
		case ECT_UNSIGNED_BYTE:
			return 0;
		case ECT_NORMALIZED_SHORT:
			return -1.f;
		case ECT_SHORT:
			return SHRT_MIN;
		case ECT_NORMALIZED_UNSIGNED_SHORT:
		case ECT_UNSIGNED_SHORT:
			return 0;
		case ECT_NORMALIZED_INT:
			return -1.f;
		case ECT_INT:
			return INT_MIN;
		case ECT_NORMALIZED_UNSIGNED_INT:
		case ECT_UNSIGNED_INT:
			return 0;
        default:
            break;
		}
		return 1.f;
	}

	//! Returns max representable value on given attribute type on given component. Only for attribute types available to get by ICPUMeshBuffer::getAttribute(uint32_t*, const E_VERTEX_ATTRIBUTE_ID&, size_t).
	/**
	@param _attrType Attribute type.
	@param _cmpnt Num of component (must be less than 4).
	@returns Max representable value or 0 if given type is not supported by this function (see maxValueOfTypeFP()) or given type does not support given amount of components.
	@see @ref maxValueOfTypeFP()
	*/
	inline uint32_t maxValueOfTypeINT(E_COMPONENT_TYPE _attrType, size_t _cmpnt)
	{
		switch (_attrType)
		{
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return 3;
			else
				return 0x3ff;
		case ECT_INT_2_10_10_10_REV:
		case ECT_INTEGER_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return 1;
			else
				return 0x3ff / 2;
		case ECT_BYTE:
		case ECT_INTEGER_BYTE:
			return SCHAR_MAX;
		case ECT_UNSIGNED_BYTE:
		case ECT_INTEGER_UNSIGNED_BYTE:
			return UCHAR_MAX;
		case ECT_SHORT:
		case ECT_INTEGER_SHORT:
			return SHRT_MAX;
		case ECT_UNSIGNED_SHORT:
		case ECT_INTEGER_UNSIGNED_SHORT:
			return USHRT_MAX;
		case ECT_INT:
		case ECT_INTEGER_INT:
			return INT_MAX;
		case ECT_UNSIGNED_INT:
		case ECT_INTEGER_UNSIGNED_INT:
			return UINT_MAX;
        default:
            break;
		}
		return 0;
	}

	//! Returns min representable value on given attribute type on given component. Only for attribute types available to get by ICPUMeshBuffer::getAttribute(uint32_t*, const E_VERTEX_ATTRIBUTE_ID&, size_t).
	/**
	@param _attrType Attribute type.
	@param _cmpnt Num of component (must be less than 4).
	@returns Min representable value or positive value if given type is not supported by this function (see minValueOfTypeFP()) or given type does not support given amount of components.
	@see @ref minValueOfTypeFP()
	*/
	inline int32_t minValueOfTypeINT(E_COMPONENT_TYPE _attrType, size_t _cmpnt)
	{
		switch (_attrType)
		{
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
		case ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV:
			return 0;
		case ECT_INT_2_10_10_10_REV:
		case ECT_INTEGER_INT_2_10_10_10_REV:
			if (_cmpnt == 3)
				return -2;
			else
				return -0x3ff/2 - 1;
		case ECT_BYTE:
		case ECT_INTEGER_BYTE:
			return SCHAR_MIN;
		case ECT_UNSIGNED_BYTE:
		case ECT_INTEGER_UNSIGNED_BYTE:
			return 0;
		case ECT_SHORT:
		case ECT_INTEGER_SHORT:
			return SHRT_MIN;
		case ECT_UNSIGNED_SHORT:
		case ECT_INTEGER_UNSIGNED_SHORT:
			return 0;
		case ECT_INT:
		case ECT_INTEGER_INT:
			return INT_MIN;
		case ECT_UNSIGNED_INT:
		case ECT_INTEGER_UNSIGNED_INT:
			return 0;
        default:
            break;
		}
		return 1;
	}

	//! Gets normalized, corresponding to given attribute type. Makes sense only for "weak integer" types.
	/**
	@param _type Given type.
	@returns Normalized corresponding to given type or ECT_COUNT for types without such.
	*/
	inline E_COMPONENT_TYPE getCorrespondingNormalizedType(E_COMPONENT_TYPE _type)
	{
		switch (_type)
		{
		case ECT_INT_2_10_10_10_REV:
			return ECT_NORMALIZED_INT_2_10_10_10_REV;
		case ECT_UNSIGNED_INT_2_10_10_10_REV:
			return ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV;
		case ECT_BYTE:
			return ECT_NORMALIZED_BYTE;
		case ECT_UNSIGNED_BYTE:
			return ECT_NORMALIZED_UNSIGNED_BYTE;
		case ECT_SHORT:
			return ECT_NORMALIZED_SHORT;
		case ECT_UNSIGNED_SHORT:
			return ECT_NORMALIZED_UNSIGNED_SHORT;
		case ECT_INT:
			return ECT_NORMALIZED_INT;
		case ECT_UNSIGNED_INT:
			return ECT_NORMALIZED_UNSIGNED_INT;
        default:
            break;
		}
		return ECT_COUNT;
	}

	//! Gets not normalized, corresponding to given attribute type. Makes sense only for normalized types.
	/**
	@param _type Given type.
	@returns Not normalized corresponding to given type or ECT_COUNT for types without such.
	*/
	inline E_COMPONENT_TYPE getCorrespondingDenormalizedType(E_COMPONENT_TYPE _type)
	{
		switch (_type)
		{
		case ECT_NORMALIZED_INT_2_10_10_10_REV:
			return ECT_INT_2_10_10_10_REV;
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
			return ECT_UNSIGNED_INT_2_10_10_10_REV;
		case ECT_NORMALIZED_BYTE:
			return ECT_BYTE;
		case ECT_NORMALIZED_UNSIGNED_BYTE:
			return ECT_UNSIGNED_BYTE;
		case ECT_NORMALIZED_SHORT:
			return ECT_SHORT;
		case ECT_NORMALIZED_UNSIGNED_SHORT:
			return ECT_UNSIGNED_SHORT;
		case ECT_NORMALIZED_INT:
			return ECT_INT;
		case ECT_NORMALIZED_UNSIGNED_INT:
			return ECT_UNSIGNED_INT;
        default:
            break;
		}
		return ECT_COUNT;
	}

    //! Gets native/true integer, corresponding to given attribute type. Makes sense only for "weak integer" types.
    /**
    @param _type Given type.
    @returns Native integer corresponding to given type or ECT_COUNT for types without such.
    */
    inline E_COMPONENT_TYPE getCorrespondingNativeIntType(E_COMPONENT_TYPE _type)
    {
        switch (_type)
        {
        case ECT_INT_2_10_10_10_REV:
            return ECT_INTEGER_INT_2_10_10_10_REV;
        case ECT_UNSIGNED_INT_2_10_10_10_REV:
            return ECT_INTEGER_UNSIGNED_INT_2_10_10_10_REV;
        case ECT_BYTE:
            return ECT_INTEGER_BYTE;
        case ECT_UNSIGNED_BYTE:
            return ECT_INTEGER_UNSIGNED_BYTE;
        case ECT_SHORT:
            return ECT_INTEGER_SHORT;
        case ECT_UNSIGNED_SHORT:
            return ECT_INTEGER_UNSIGNED_SHORT;
        case ECT_INT:
            return ECT_INTEGER_INT;
        case ECT_UNSIGNED_INT:
            return ECT_INTEGER_UNSIGNED_INT;
        default:
            break;
        }
        return ECT_COUNT;
    }

	inline core::vectorSIMDf denormalizeAttribute(E_COMPONENT_TYPE _srcType, const core::vectorSIMDf& _in)
	{
		switch (_srcType)
		{
		case ECT_NORMALIZED_INT_2_10_10_10_REV:
			return _in * core::vectorSIMDf(511.f, 511.f, 511.f, 1.f);
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
			return _in * core::vectorSIMDf(1023.f, 1023.f, 1023.f, 3.f);
		case ECT_NORMALIZED_BYTE:
			return _in * (float)SCHAR_MAX;
		case ECT_NORMALIZED_UNSIGNED_BYTE:
			return _in * (float)UCHAR_MAX;
		case ECT_NORMALIZED_SHORT:
			return _in * (float)SHRT_MAX;
		case ECT_NORMALIZED_UNSIGNED_SHORT:
			return _in * (float)USHRT_MAX;
		case ECT_NORMALIZED_INT:
			return _in * (float)INT_MAX;
		case ECT_NORMALIZED_UNSIGNED_INT:
			return _in * (float)UINT_MAX;
        default:
            break;
		}
		return _in;
	}

	inline core::vectorSIMDf normalizeAttribute(E_COMPONENT_TYPE _dstType, const core::vectorSIMDf& _in)
	{
		switch (_dstType)
		{
		case ECT_NORMALIZED_INT_2_10_10_10_REV:
			return _in / core::vectorSIMDf(511.f, 511.f, 511.f, 1.f);
		case ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV:
			return _in / core::vectorSIMDf(1023.f, 1023.f, 1023.f, 3.f);
		case ECT_NORMALIZED_BYTE:
			return _in / (float)SCHAR_MAX;
		case ECT_NORMALIZED_UNSIGNED_BYTE:
			return _in / (float)UCHAR_MAX;
		case ECT_NORMALIZED_SHORT:
			return _in / (float)SHRT_MAX;
		case ECT_NORMALIZED_UNSIGNED_SHORT:
			return _in / (float)USHRT_MAX;
		case ECT_NORMALIZED_INT:
			return _in / (float)INT_MAX;
		case ECT_NORMALIZED_UNSIGNED_INT:
			return _in / (float)UINT_MAX;
        default:
            break;
		}
		return _in;
	}

	template <class T>
	class IMeshDataFormatDesc : public virtual core::IReferenceCounted
	{
        protected:
			//! Read https://www.khronos.org/opengl/wiki/Vertex_Specification for understanding of attribute IDs, indices, attribute formats etc.
            E_COMPONENTS_PER_ATTRIBUTE compntsPerAttr[EVAI_COUNT];
            E_COMPONENT_TYPE attrType[EVAI_COUNT];
            size_t attrStride[EVAI_COUNT];
            size_t attrOffset[EVAI_COUNT];
            uint32_t attrDivisor[EVAI_COUNT];

            //vertices
            T* mappedAttrBuf[scene::EVAI_COUNT];
            //indices
            T* mappedIndexBuf;

            virtual ~IMeshDataFormatDesc()
            {
                for (size_t i=0; i<EVAI_COUNT; i++)
                {
                    if (mappedAttrBuf[i])
                        mappedAttrBuf[i]->drop();
                }

                if (getIndexBuffer())
                    getIndexBuffer()->drop();
            }
        public:
            //! Default constructor.
            IMeshDataFormatDesc()
            {
                for (size_t i=0; i<EVAI_COUNT; i++)
                {
                    compntsPerAttr[i] = ECPA_FOUR;
                    attrType[i] = ECT_FLOAT;
                    attrStride[i] = 16;
                    attrOffset[i] = 0;
                    attrDivisor[i] = 0;
                    mappedAttrBuf[i] = NULL;
                }
                mappedIndexBuf = NULL;
            }

            inline bool formatCanBeAppended(const IMeshDataFormatDesc<T>* other) const
            {
                bool retVal = true;
                for (size_t i=0; retVal&&i<EVAI_COUNT; i++)
                {
                    if (this->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                    {
                        if (other->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                            retVal = retVal&&compntsPerAttr[i]==other->compntsPerAttr[i]&&attrType[i]==other->attrType[i];
                        else
                            return false;
                    }
                    else
                    {
                        if (other->getMappedBuffer(static_cast<E_VERTEX_ATTRIBUTE_ID>(i)))
                            return false;
                        else
                            retVal = retVal&&compntsPerAttr[i]==other->compntsPerAttr[i]&&attrType[i]==other->attrType[i];
                    }
                }
                return retVal;
            }

            inline void mapIndexBuffer(T* ixbuf)
            {
        /*
        #ifdef _DEBUG
                if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset)) //not that easy to check
                {
                    os::Printer::log("MeshBuffer map index buffer overflow!\n",ELL_ERROR);
                    return;
                }
        #endif // _DEBUG
        */
                if (ixbuf)
                    ixbuf->grab();

                if (mappedIndexBuf)
                    mappedIndexBuf->drop();
                mappedIndexBuf = ixbuf;
            }

            inline const T* getIndexBuffer() const
            {
                return mappedIndexBuf;
            }


            //! remember that the divisor needs to be <=0x1u<<_IRR_VAO_MAX_ATTRIB_DIVISOR_BITS
            virtual void mapVertexAttrBuffer(T* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0, uint32_t divisor=0) = 0;

            inline const T* getMappedBuffer(const scene::E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return mappedAttrBuf[attrId];
            }


            inline const E_COMPONENT_TYPE& getAttribType(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrType[attrId];
            }

            inline const E_COMPONENTS_PER_ATTRIBUTE& getAttribComponentCount(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return compntsPerAttr[attrId];
            }

            inline void setMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId, const size_t &offset)
            {
                assert(attrId<EVAI_COUNT);

                if (!mappedAttrBuf[attrId])
                    return;

                attrOffset[attrId] = offset;
            }

            inline const size_t& getMappedBufferOffset(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrOffset[attrId];
            }

            inline const size_t& getMappedBufferStride(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrStride[attrId];
            }

            inline const uint32_t& getAttribDivisor(const E_VERTEX_ATTRIBUTE_ID& attrId) const
            {
                assert(attrId<EVAI_COUNT);
                return attrDivisor[attrId];
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId)
            {
                swapVertexAttrBuffer(attrBuf, attrId, attrOffset[attrId], attrStride[attrId]);
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset)
            {
                swapVertexAttrBuffer(attrBuf, attrId, newOffset, attrStride[attrId]);
            }

            inline void swapVertexAttrBuffer(T* attrBuf, const scene::E_VERTEX_ATTRIBUTE_ID& attrId, const size_t& newOffset, const size_t& newStride)
            {
                if (!mappedAttrBuf[attrId] || !attrBuf)
                    return;

                attrBuf->grab();
                mappedAttrBuf[attrId]->drop();

                mappedAttrBuf[attrId] = attrBuf;
                attrOffset[attrId] = newOffset;
                attrStride[attrId] = newStride;
            }
	};


	class ICPUMeshDataFormatDesc : public IMeshDataFormatDesc<asset::ICPUBuffer>, core::BlobSerializable
	{
        protected:
	        ~ICPUMeshDataFormatDesc()
	        {
	        }
	    public:
			virtual void* serializeToBlob(void* _stackPtr = NULL, const size_t& _stackSize = 0) const
			{
				return core::CorrespondingBlobTypeFor<IMeshDataFormatDesc<asset::ICPUBuffer> >::type::createAndTryOnStack(static_cast<const IMeshDataFormatDesc<asset::ICPUBuffer>*>(this), _stackPtr, _stackSize);
			}

            //! remember that the divisor needs to be <=0x1u<<_IRR_VAO_MAX_ATTRIB_DIVISOR_BITS
            void mapVertexAttrBuffer(asset::ICPUBuffer* attrBuf, const E_VERTEX_ATTRIBUTE_ID& attrId, E_COMPONENTS_PER_ATTRIBUTE components, E_COMPONENT_TYPE type, const size_t &stride=0, size_t offset=0, uint32_t divisor=0)
            {
                assert(attrId<EVAI_COUNT);
        #ifdef _DEBUG
                if (!validCombination(type,components))
                {
                    //os::Printer::log("MeshBuffer mapVertexAttrBuffer INVALID COMBINATION OF COMPONENT TYPE AND COUNT!\n",ELL_ERROR);
                    return;
                }
        #endif // _DEBUG

                if (attrBuf)
                {
                    attrBuf->grab();

                    compntsPerAttr[attrId] = components;
                    attrType[attrId] = type;
                    attrStride[attrId] = stride!=0 ? stride:vertexAttrSize[type][components];
                    attrOffset[attrId] = offset;
                    attrDivisor[attrId] = divisor;
                }
                else
                {
                    compntsPerAttr[attrId] = ECPA_FOUR;
                    attrType[attrId] = ECT_FLOAT;
                    attrStride[attrId] = 16;
                    attrOffset[attrId] = 0;
                    attrDivisor[attrId] = 0;
                }

                if (mappedAttrBuf[attrId])
                    mappedAttrBuf[attrId]->drop();
                mappedAttrBuf[attrId] = attrBuf;
            }
	};

	class IGPUMeshDataFormatDesc : public IMeshDataFormatDesc<video::IGPUBuffer>
	{
	};




	template <class T>
	class IMeshBuffer : public virtual core::IReferenceCounted
	{
        using MaterialType = typename std::conditional<std::is_same<T, asset::ICPUBuffer>::value, video::SCPUMaterial, video::SGPUMaterial>::type;

    protected:
	    virtual ~IMeshBuffer()
	    {
            if (leakDebugger)
                leakDebugger->deregisterObj(this);

            if (meshLayout)
                meshLayout->drop();
	    }

        MaterialType Material;
        core::aabbox3df boundingBox;
        IMeshDataFormatDesc<T>* meshLayout;
	    //indices
	    E_INDEX_TYPE indexType;
	    int32_t baseVertex;
        uint64_t indexCount;
        size_t indexBufOffset;
        //
        size_t instanceCount;
        uint32_t baseInstance;
        //primitives
        E_PRIMITIVE_TYPE primitiveType;

        //debug
        core::LeakDebugger* leakDebugger;
	public:
		//! Constructor.
		/**
		@param layout Pointer to descriptor of mesh data object. Will be grabbed.
		@param dbgr Pointer to leak debugger object.
		*/
	    IMeshBuffer(IMeshDataFormatDesc<T>* layout=NULL, core::LeakDebugger* dbgr=NULL) : leakDebugger(dbgr)
	    {
            if (leakDebugger)
                leakDebugger->registerObj(this);

	        meshLayout = layout;
	        if (meshLayout)
                meshLayout->grab();

            indexType = EIT_UNKNOWN;
            baseVertex = 0;
            indexCount = 0;
            indexBufOffset = 0;

	        primitiveType = EPT_TRIANGLES;

            instanceCount = 1;
            baseInstance = 0;
	    }

		//! Access data descriptor objects.
		/** @returns data descriptor object. */
	    inline IMeshDataFormatDesc<T>* getMeshDataAndFormat() {return meshLayout;}
		//! @copydoc getMeshDataAndFormat()
	    inline const IMeshDataFormatDesc<T>* getMeshDataAndFormat() const {return meshLayout;}
		//! Sets data descriptor object.
		/**
		Grabs the new object and drops the old one.
		@param layout new descriptor object.
		*/
	    inline void setMeshDataAndFormat(IMeshDataFormatDesc<T>* layout)
	    {
	        if (layout)
                layout->grab();

	        if (meshLayout)
                meshLayout->drop();
            meshLayout = layout;
	    }

		//! Get type of index data which is stored in this meshbuffer.
		/** \return Index type of this buffer. */
		inline const E_INDEX_TYPE& getIndexType() const {return indexType;}
		inline void setIndexType(const E_INDEX_TYPE& type) {indexType = type;}

		//! Sets offset in mapped index buffer.
		/** @param byteOffset Offset in bytes. */
		inline void setIndexBufferOffset(const size_t& byteOffset) {indexBufOffset = byteOffset;}
		//! Accesses offset in mapped index buffer.
		/** @returns Offset in bytes. */
		inline const size_t& getIndexBufferOffset() const {return indexBufOffset;}

		//! Get amount of indices in this meshbuffer.
		/** \return Number of indices in this buffer. */
		inline const uint64_t& getIndexCount() const {return indexCount;}
		//! Sets amount of indices.
		/** @returns Whether set amount exceeds mapped buffer's size. Regardless of result the amount is set. */
		inline bool setIndexCount(const uint64_t &newIndexCount)
		{
/*
#ifdef _DEBUG
            if (size<0x7fffffffffffffffuLL&&ixbuf&&(ixbuf->getSize()>size+offset))
            {
                os::Printer::log("MeshBuffer map vertex buffer overflow!\n",ELL_ERROR);
                return;
            }
#endif // _DEBUG
*/
            indexCount = newIndexCount;
            if (meshLayout)
            {
                const T* mappedIndexBuf = meshLayout->getIndexBuffer();
                if (mappedIndexBuf)
                {
                    switch (indexType)
                    {
                        case EIT_16BIT:
                            return indexCount*2+indexBufOffset<mappedIndexBuf->getSize();
                        case EIT_32BIT:
                            return indexCount*4+indexBufOffset<mappedIndexBuf->getSize();
                        default:
                            return false;
                    }
                }
            }

            return true;
		}

		//! Accesses base vertex number.
		/** @returns base vertex number. */
        inline const int32_t& getBaseVertex() const {return baseVertex;}
		//! Sets base vertex.
        inline void setBaseVertex(const int32_t& baseVx)
        {
            baseVertex = baseVx;
        }


		inline const E_PRIMITIVE_TYPE& getPrimitiveType() const {return primitiveType;}
		inline void setPrimitiveType(const E_PRIMITIVE_TYPE& type)
		{
		    primitiveType = type;
		}

		inline const size_t& getInstanceCount() const {return instanceCount;}
		inline void setInstanceCount(const size_t& count)
		{
		    instanceCount = count;
		}

		inline const uint32_t& getBaseInstance() const {return baseInstance;}
		inline void setBaseInstance(const uint32_t& base)
		{
		    baseInstance = base;
		}


		//! Get the axis aligned bounding box of this meshbuffer.
		/** \return Axis aligned bounding box of this buffer. */
		inline const core::aabbox3df& getBoundingBox() const {return boundingBox;}

		//! Set axis aligned bounding box
		/** \param box User defined axis aligned bounding box to use
		for this buffer. */
		inline void setBoundingBox(const core::aabbox3df& box)
		{
		    boundingBox = box;
		}

		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline const MaterialType& getMaterial() const
		{
			return Material;
		}


		//! Get material of this meshbuffer
		/** \return Material of this buffer */
		inline MaterialType& getMaterial()
		{
			return Material;
		}
	};

	class IGPUMeshBuffer : public IMeshBuffer<video::IGPUBuffer>
	{
            video::ITransformFeedback* attachedXFormFeedback;
            uint32_t attachedXFormFeedbackStream;
        protected:
            virtual ~IGPUMeshBuffer()
            {
                if (attachedXFormFeedback)
                    attachedXFormFeedback->drop();
            }
        public:
            IGPUMeshBuffer(core::LeakDebugger* dbgr=NULL) : IMeshBuffer<video::IGPUBuffer>(NULL,dbgr), attachedXFormFeedback(NULL), attachedXFormFeedbackStream(0) {}

            inline void setIndexCountFromXFormFeedback(video::ITransformFeedback* xformFeedback, const uint32_t & stream)
            {
                attachedXFormFeedbackStream = stream;


                if (xformFeedback==attachedXFormFeedback)
                    return;

                if (!xformFeedback)
                {
                    if (attachedXFormFeedback)
                        attachedXFormFeedback->drop();

                    attachedXFormFeedback = NULL;
                    return;
                }

                xformFeedback->grab();
                if (attachedXFormFeedback)
                    attachedXFormFeedback->drop();
                attachedXFormFeedback = xformFeedback;

                indexType = EIT_UNKNOWN;
                indexCount = 0;
            }

            inline video::ITransformFeedback* getXFormFeedback() const {return attachedXFormFeedback;}

            inline const uint32_t& getXFormFeedbackStream() const {return attachedXFormFeedbackStream;}

            bool isIndexCountGivenByXFormFeedback() const {return attachedXFormFeedback!=NULL;}
	};

#include "irr/irrpack.h"
    struct SkinnedVertexIntermediateData
    {
        SkinnedVertexIntermediateData()
        {
            memset(this,0,20);
        }
        uint8_t boneIDs[4];
        float boneWeights[4];
    } PACK_STRUCT;

    struct SkinnedVertexFinalData
    {
        public:
            uint8_t boneIDs[4];
            uint32_t boneWeights; //ECT_NORMALIZED_UNSIGNED_INT_2_10_10_10_REV
    } PACK_STRUCT;
#include "irr/irrunpack.h"

} // end namespace scene
} // end namespace irr

namespace std
{
	template <>
	struct hash<irr::scene::E_VERTEX_ATTRIBUTE_ID>
	{
		std::size_t operator()(const irr::scene::E_VERTEX_ATTRIBUTE_ID& k) const noexcept {return k;}
	};

	template <>
	struct hash<irr::scene::E_COMPONENT_TYPE>
	{
		std::size_t operator()(const irr::scene::E_COMPONENT_TYPE& k) const noexcept { return k; }
	};
}

#endif


